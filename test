using ArcGIS.Core.Geometry;
using ArcGIS.Desktop.Framework.Threading.Tasks;
using ArcGIS.Desktop.Mapping;
using System;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace BasemappingPro.ui.maplayout
{
    internal class ProjectionBuilderInfo
    {
        internal sealed class ProjectionInfo
        {
            public string ProjectionName { get; init; } = "";
            public string Zone { get; init; } = "N/A";
            public string Datum { get; init; } = "";
            public string Units { get; init; } = "";
            public string Spheroid { get; init; } = "";
        }

        /// <summary>
        /// Reads the spatial reference from the single layer in the active map (fallback: map SR)
        /// and returns projection fields similar to legacy ArcMap Java logic.
        /// </summary>
        public static async Task<ProjectionInfo?> GetFromActiveSingleLayerAsync()
        {
            return await QueuedTask.Run(() =>
            {
                var mv = MapView.Active;
                var map = mv?.Map;
                if (map == null) return null;

                // Assume only one layer (as requested). If none, fallback to map SR.
                var layer = map.GetLayersAsFlattenedList().FirstOrDefault();

                SpatialReference? sr = null;
                try
                {
                    // Some layer types expose SR; fallback to map SR always works.
                    sr = layer?.GetSpatialReference() ?? map.SpatialReference;
                }
                catch
                {
                    sr = map.SpatialReference;
                }

                if (sr == null) return null;

                //
                string srName = sr.Name ?? "";
                string units = sr.Unit?.Name ?? "";
                string datum = "";
                string spheroid = "";
                try
                {
                    datum = sr.Datum?.Name ?? "";
                    spheroid = sr.Datum?.SpheroidWkid.ToString();
                    //spheroid = sr.Datum?.Spheroid?.Name ?? "";
                }
                catch { }

                // Zone parsing (legacy-style: inferred from SR name)
                string zone = ParseZoneFromSpatialRefName(srName);

                // datum hint from name if properties aren't available
                if (string.IsNullOrWhiteSpace(datum))
                {
                    if (srName.IndexOf("NAD 1983 (2011)", StringComparison.OrdinalIgnoreCase) >= 0) datum = "NAD 1983 (2011)";
                    else if (srName.IndexOf("NAD 1983", StringComparison.OrdinalIgnoreCase) >= 0) datum = "NAD 1983";
                    else if (srName.IndexOf("WGS 1984", StringComparison.OrdinalIgnoreCase) >= 0) datum = "WGS 1984";
                }

                return new ProjectionInfo
                {
                    ProjectionName = srName,
                    Zone = zone,
                    Datum = datum,
                    Units = units,
                    Spheroid = spheroid
                };
            });
        }

        //The concept of a "zone" is generally associated with Projected Coordinate Systems (PCS)
        private static string ParseZoneFromSpatialRefName(string srName)
        {
            if (string.IsNullOrWhiteSpace(srName))
                return "N/A";

            // Normalize ArcMap-style underscores to spaces
            string n = srName.Replace('_', ' ');

            // StatePlane:
            var mStatePlane = Regex.Match(n, 
                @"StatePlane\s+(?<zone>.+?)(\(|$)", 
                RegexOptions.IgnoreCase);
            if (mStatePlane.Success)
                return mStatePlane.Groups["zone"].Value.Trim();

            // UTM:
            var mUtm = Regex.Match(n, 
                @"UTM\s+Zone\s+(?<zone>\d{1,2}\s*[NS]?)", 
                RegexOptions.IgnoreCase);
            if (mUtm.Success)
                return "UTM Zone " + mUtm.Groups["zone"].Value.Trim();

            // GCS usually has no zone!!!!!
            if (n.IndexOf("GCS", StringComparison.OrdinalIgnoreCase) >= 0 ||
                n.IndexOf("Geographic", StringComparison.OrdinalIgnoreCase) >= 0)
                return "GCS No Zone";

            return "N/A";
        }
    }
}
